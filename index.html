<!DOCTYPE html>
<html lang="en" style="width:100%;height:100%;">
  <head>
    <meta charset="utf-8">
		<title>Aether</title>
		<script src="https://cjrtnc.leaningtech.com/4.1/loader.js"></script>
		<link rel="stylesheet" href="style.css">
		<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
	</head>
  <body>
		<header>
			<div class="desktop-only">
				<div class="container">
					<div class="intro">
						<label for="version-select">Select Version:</label>
						<select id="version-select"></select>
						<label for="mod-upload">Upload Mod ZIP:</label>
						<input type="file" id="mod-upload" accept=".zip" multiple />
						<ul id="mod-list" style="margin:10px 0 0 0;"></ul>
						<button id="play-btn">Play!</button>
						<p>Only 1.2.5 is supported (the jar file are missing for other versions)</p>
						<a href="https://browserforge.vercel.app/The%20Aether%20Mod.zip">Download Aether Mod</a>
						<a href="http://browserforge.vercel.app/MC%201.2.5%20-%20Player%20API%20client%201.5.zip">Download MC Player API (required for The Aether mod).</a>
					</div>
					<progress style="display: none"></progress>
					<div class="display"></div>
				</div>
			</div>
		</header>

		<script type="module">
			import MinecraftClient from "./minecraft-web.js";

			// Fetch versions.json and populate dropdown
			const versionSelect = document.getElementById('version-select');
			let versionType = 'zip'; // default
			fetch('./mc/versions.json')
  .then(res => res.json())
  .then(versions => {
    window.versionsData = versions; // keep a reference
    versions.forEach((v, i) => {
      const opt = document.createElement('option');
      opt.value = v.jar;
      opt.textContent = v.name;
      opt.dataset.type = v.type || 'zip';
      if (v.class) opt.dataset.class = v.class;
      versionSelect.appendChild(opt);
    });
    // Initialize global state from first version
    const first = versions[0];
    window.selectedVersionClass = first?.class;
    window.selectedVersionLibraries = first?.libraries || [];
    window.selectedVersionJvmArgs = first?.jvmArgs || [];
    versionType = first?.type || 'zip';
    updateModUploadLabel();
  });

versionSelect.addEventListener('change', () => {
  const idx = versionSelect.selectedIndex;
  const selected = window.versionsData[idx] || {};
  window.selectedVersionClass = selected.class;
  window.selectedVersionLibraries = selected.libraries || [];
  window.selectedVersionJvmArgs = selected.jvmArgs || [];
  versionType = selected.type || 'zip';
  updateModUploadLabel();
  uploadedMods = [];
  updateModList();
});

			function updateModUploadLabel() {
				const label = document.querySelector('label[for="mod-upload"]');
				if (versionType === 'jar') {
					label.textContent = 'Upload Mod JAR:';
					modUpload.accept = '.jar';
				} else if (versionType === 'jar-zip') {
					label.textContent = 'Upload Mod ZIP or JAR:';
					modUpload.accept = '.zip,.jar';
				} else {
					label.textContent = 'Upload Mod ZIP:';
					modUpload.accept = '.zip';
				}
			}

			let moddedJarBlob = null;

			// Handle mod upload and jar patching
			const modUpload = document.getElementById('mod-upload');
			const modList = document.getElementById('mod-list');
			let uploadedMods = [];

			function updateModList() {
				modList.innerHTML = '';
				uploadedMods.forEach((mod, idx) => {
					const li = document.createElement('li');
					li.textContent = mod.name + ' ';
					const removeBtn = document.createElement('button');
					removeBtn.textContent = 'Remove';
					removeBtn.onclick = () => {
						uploadedMods.splice(idx, 1);
						updateModList();
					};
					li.appendChild(removeBtn);
					modList.appendChild(li);
				});
			}

			const progress = document.querySelector('progress');

			// Make uploadedMods and versionType available globally for minecraft-web.js
window.uploadedMods = uploadedMods;
window.versionType = versionType;
// Set selectedVersionClass for MinecraftClient
const selected = versionSelect.options[versionSelect.selectedIndex];
window.selectedVersionClass = selected?.dataset.class || undefined;

			// Play button logic
			const playBtn = document.getElementById('play-btn');
			playBtn.addEventListener('click', async () => {
  progress.style.display = '';
  progress.value = 0;
  progress.max = 4;
  try {
    let jarBlob = null;
    let jarSource;
    if (uploadedMods.length > 0 && versionType === 'zip') {
      jarBlob = await patchJarWithMods();
      jarSource = jarBlob;
    } else {
      jarSource = versionSelect.value;
    }
    // Ensure global state is up to date for minecraft-web.js
    window.uploadedMods = uploadedMods;
    window.versionType = versionType;
    progress.value = 1;
    await cheerpjInit({
      version: 17,
      javaProperties: ["java.library.path=/app/libraries/"],
      libraries: {"libGL.so.1": "/app/libraries/gl4es.wasm"},
      enableX11:true,
    });
    progress.value = 2;
    const mc = new MinecraftClient(jarSource, undefined, progress);
    await mc.run();
    progress.value = 4;
    setTimeout(() => { progress.style.display = 'none'; }, 1000);
  } catch (err) {
    progress.style.display = 'none';
    console.error(err);
  }
});

			modUpload.addEventListener('change', async (e) => {
				try {
					const files = Array.from(e.target.files);
					if (!files.length) {
						return;
					}
					files.forEach(file => {
						if (!uploadedMods.some(f => f.name === file.name)) {
							if (versionType === 'jar' && !file.name.endsWith('.jar')) return;
							if (versionType === 'zip' && !file.name.endsWith('.zip')) return;
							if (versionType === 'jar-zip' && !(file.name.endsWith('.zip') || file.name.endsWith('.jar'))) return;
							uploadedMods.push(file);
						}
					});
					updateModList();
				} catch (err) {
					console.error(err);
				}
			});

			// patchJarWithMods now returns the new jar Blob
			async function patchJarWithMods() {
  try {
    if (versionType === 'jar') {
      // No merging, mods will be handled as jars in mods folder
      return null;
    }
    // For both 'zip' and 'jar-zip', merge all ZIPs into the base JAR
    if (versionType === 'zip' || versionType === 'jar-zip') {
      // Only merge ZIPs, JARs will be handled as Forge mods (for jar-zip)
      const zipMods = uploadedMods.filter(f => f.name.endsWith('.zip'));
      if (zipMods.length === 0) {
        progress.style.display = 'none';
        return null;
      }
      progress.style.display = '';
      progress.value = 0;
      // Count total files for better progress
      let totalFiles = 0;
      for (const file of zipMods) {
        try {
          const modZip = await JSZip.loadAsync(file);
          totalFiles += Object.keys(modZip.files).filter(fname => !modZip.files[fname].dir).length;
        } catch {}
      }
      progress.max = totalFiles + 2; // +2 for jar load and jar save
      const versionJarPath = versionSelect.value;
      let jarResp;
      try {
        jarResp = await fetch(versionJarPath);
        if (!jarResp.ok) throw new Error('Failed to fetch base jar: ' + jarResp.statusText);
      } catch (err) {
        progress.style.display = 'none';
        throw err;
      }
      let jarBuf;
      try {
        jarBuf = await jarResp.arrayBuffer();
      } catch (err) {
        progress.style.display = 'none';
        throw err;
      }
      progress.value++;
      const zip = new JSZip();
      try {
        await zip.loadAsync(jarBuf);
      } catch (err) {
        progress.style.display = 'none';
        throw err;
      }
      let doneFiles = 0;
      for (const [i, file] of zipMods.entries()) {
        let modZip;
        try {
          modZip = await JSZip.loadAsync(file);
        } catch (err) {
          continue;
        }
        const modFileNames = Object.keys(modZip.files).filter(fname => !modZip.files[fname].dir);
        for (const fname of modFileNames) {
          try {
            const content = await modZip.files[fname].async('uint8array');
            zip.file(fname, content);
            doneFiles++;
            progress.value = 1 + doneFiles;
          } catch (err) {}
        }
      }
      progress.value = totalFiles + 1;
      let newJarBuf;
      try {
        newJarBuf = await zip.generateAsync({type: 'uint8array'});
      } catch (err) {
        progress.style.display = 'none';
        throw err;
      }
      progress.value = progress.max;
      setTimeout(() => { progress.style.display = 'none'; }, 1000);
      return new Blob([newJarBuf], {type: 'application/java-archive'});
    }
    return null;
  } catch (err) {
    progress.style.display = 'none';
    throw err;
  }
}
		</script>
  </body>
</html>
